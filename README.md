# РЕФАЛ-машина

## О языке РЕФАЛ

РЕкурсивных Формул АЛгоритмический является одним из старейший языков программирования.
Создал его в 60-х годах прошлого столетия [Валентин Фёдорович Турчин](https://computer-museum.ru/histussr/turchin_sorucom_2011.htm).
С тех пор вышел ряд отличающихся синтаксисом и семантикой версий. Интересующимся
рекомендуется ознакомиться со [сравнением](https://github.com/Mazdaywik/direct-link/blob/master/refal-compare.md),
которое составил ведущий разработчик компилятора [Рефал-5λ](https://github.com/bmstu-iu9/refal-5-lambda)
Александр Коновалов.

## О реализации

РЕФАЛ-машина предназначена для исполнения написанных на РЕФАЛ сценариев
(поддерживается пока только [Базисный РЕФАЛ](doc/%D0%A0%D0%95%D0%A4%D0%90%D0%9B-5%20%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE%20%D0%BF%D0%BE%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E%20%D0%B8%20%D1%81%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%20%D0%A2%D1%83%D1%80%D1%87%D0%B8%D0%BD%20%D0%92.%D0%A4.pdf), за исключением нескольких встроенных функций) в ОС Linux. Реализована на яыке Си и имеет минимум зависимостей (в том числе от стандартной библиотеки Си). Представляет собой (потенциально) встраиваемый интерпретатор, предварительно транслирующий исходный текст в байт-код, который и исполняется. Трансляция выполняется в один проход, однако, поддерживается традиционный для РЕФАЛ произвольный порядок определения функций.

Основные отличия:
* Поддержка кириллицы (и практически любых Уникод-сомволов) в идентификаторах.
* Префиксы `s.` `t.` и `e.` переменных могут быть соответственно `?` `!` и `.` или `…`
* Начинающиеся с `$` директивы не поддерживаются.
* В вычислительных скобках `< >` имя вызываемой функции не обязательно должно
идти непосредственно после открывающей скобки, перед ним можно расположить данные
или простой идентификатор. Транслятор знает, что можно вызвать. Это же послабление
относится и к функции `Mu`, которая выполняет поиск вызываемой функции среди
аргументов во время выполнения (пропуская структурные скобки).
* Помимо точки входа `Go` возможно использовать `Main`, которая принимает в поле
зрения аргументы командной строки (каждый заключён в структурные скобки, как в
результате `ArgList` из [LibraryEx](https://github.com/Mazdaywik/refal-5-framework/blob/master/docs/LibraryEx.md#функция-arglist)).
Кроме того, поддерживается точка входа `Начало` — в таком случае интерпретатор
проверяет, содержит ли первое её предложение образец, надо ли передавать аргументы.
Допустимы вышеперечисленные имена, начинающиеся со строчной буквы — результат их
исполнения выводится, а не отбрасывается.
* Поддержаны функции из одного предложения, без блока `{ }`.

        // Допустимы комментарии в одну строку в стиле С++
        
        * Вариант классической РЕФАЛ-программы.
        
        Начало = <Палиндром? <удалить пробелы "я разуму уму заря    ">>
                 <Палиндром? <удалить пробелы "я иду съ мечемъ судия">>;
                                                     * Гавриил Державин
        
        Палиндром? {
           ?символ … ?символ = <Палиндром? …>;
           ?символ           = <Вывод "Палиндром">;
                             = <Вывод "Палиндром">;
                   …         = <Вывод "Остаток: "…>;
        }
        
        удалить {
           пробелы .символы " " .остаток = <удалить пробелы .символы .остаток>;
           пробелы … = …;
        }
        
        * явное определение не обязательно.
        пробелы;
        
        Вывод . = <Prout .>;

Для вызова функций, реализованных в другой единице трансляции (модуле), следует
импортировать модуль явно. Для чего указывается имя модуля, завершаемое двоеточием:

        Модуль: функция1 функция2;

РЕФАЛ-машина ищет реализацию модуля в файлах `Модуль.реф` и `Модуль.ref`.
Указанные в команде импорта идентификаторы вносится в текущую область пространства
имён. Остальные идентификаторы модуля так же доступны, если их имя предварительно
квалифицировать именем модуля:

        * Импортируем идентификаторы тест1 и тест2 из файла "Модуль1.реф"
        Модуль1: тест1 тест2;
        go = <тест1> <тест2>
           * Вызов по полному имени.
               <Модуль1 тест3>;

### Ограничения

На текущем этапе РЕФАЛ-машина способна [исполнить Refal-05](examples/refal-05.sh)
(после внесения [изменений](examples/refal-05.v3.1.patch)). Оптимизация
интерпретатора не производилась, потому придётся подождать. Транслятор наверняка
выдаст неожиданный результат, если предложить ему некорректный исходный текст.
